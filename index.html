<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmileCraft</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            width: 360px;
            height: 640px;
            position: relative;
            background: #f0f8ff;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        canvas {
            display: block;
            background: #f0f8ff;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(255,255,255,0.9);
            padding: 15px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .tool {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 12px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .tool:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        .tool.active {
            background: #4CAF50;
            color: white;
            transform: scale(1.1);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        #score, #comfort, #timer {
            background: rgba(255,255,255,0.9);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        #comfort {
            background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
            background-size: 100% 100%;
            color: white;
            position: relative;
            overflow: hidden;
        }

        #comfort::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--comfort-width, 100%);
            background: rgba(255,255,255,0.3);
            transition: width 0.3s ease;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            display: none;
            pointer-events: auto;
        }

        #restartBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
            transition: background 0.2s ease;
        }

        #restartBtn:hover {
            background: #45a049;
        }

        #toolCursor {
            position: absolute;
            pointer-events: none;
            transition: opacity 0.2s ease;
            opacity: 0;
            z-index: 100;
        }

        .cursor-brush {
            width: 25px;
            height: 120px;
            background: linear-gradient(135deg, #FFE135, #FFA502);
            border-radius: 12px 12px 3px 3px;
            border: 2px solid #333;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .cursor-brush::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 12px;
            background: #8B4513;
            border-radius: 0 0 3px 3px;
        }

        .cursor-brush::before {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 3px;
            background: #ff0000;
            border-radius: 50%;
            z-index: 10;
        }

        .cursor-scaler {
            width: 20px;
            height: 130px;
            background: linear-gradient(135deg, #C0C0C0, #808080);
            border: 2px solid #333;
            border-radius: 2px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .cursor-scaler::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 12px solid #666;
        }

        .cursor-scaler::before {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 3px;
            background: #ff0000;
            border-radius: 50%;
            z-index: 10;
        }

        .cursor-drill {
            width: 25px;
            height: 125px;
            background: linear-gradient(135deg, #FF4757, #FF3742);
            border: 2px solid #333;
            border-radius: 8px 8px 2px 2px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .cursor-drill::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 15px;
            background: #333;
            border-radius: 1px;
        }

        .cursor-drill::before {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 3px;
            background: #ff0000;
            border-radius: 50%;
            z-index: 10;
        }

        .cursor-rinse {
            width: 30px;
            height: 110px;
            background: linear-gradient(135deg, #3DAFFF, #2ED573);
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .cursor-rinse::after {
            content: 'üíß';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
        }

        .cursor-rinse::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 3px;
            height: 3px;
            background: #ff0000;
            border-radius: 50%;
            z-index: 10;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            font-size: 12px;
            font-weight: bold;
            color: #ff6b6b;
            animation: particle-float 1s ease-out forwards;
        }

        @keyframes particle-float {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-30px) scale(0.5); }
        }

        .perfect-smile {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            animation: perfect-smile 2s ease-out forwards;
            pointer-events: none;
        }
        @keyframes perfect-smile {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="360" height="640"></canvas>
        <div id="toolCursor" class="cursor-brush"></div>
        <div id="ui">
                <div id="score">Score: 0</div>
                <div id="comfort">‚ù§Ô∏è <span id="comfortValue">100</span></div>
                <div id="timer">‚è∞ <span id="timerValue">60</span></div>
            </div>
            <div id="toolbar">
                <button class="tool active" data-tool="brush">ü™•</button>
                <button class="tool" data-tool="scaler">‚õèÔ∏è</button>
                <button class="tool" data-tool="drill">üõ†Ô∏è</button>
                <button class="tool" data-tool="rinse">üíß</button>
            </div>
            <div id="gameOver">
                <h2 id="gameOverTitle">Time's Up!</h2>
                <p id="finalScore">Final Score: 0</p>
                <button id="restartBtn">New Patient</button>
            </div>
        </div>
    </div>

    <script>
        class SmileCraft {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 360;
                this.height = 640;
                
                this.currentTool = 'brush';
                this.score = 0;
                this.comfort = 100;
                this.timeLeft = 60;
                this.gameRunning = false;
                this.drillHeat = 0;
                this.drillCharging = false;
                this.drillCharge = 0;
                
                this.teeth = [];
                this.particles = [];
                this.problems = [];
                
                this.mouse = { x: 0, y: 0, down: false, touches: 0, toolX: 0, toolY: 0 };
                this.toolbarTimeout = null;
                this.toolCursor = document.getElementById('toolCursor');
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.generateMouth();
                this.startGame();
            }
            
            setupEventListeners() {
                // Tool selection
                document.querySelectorAll('.tool').forEach(tool => {
                    tool.addEventListener('click', (e) => {
                        this.selectTool(e.target.dataset.tool);
                    });
                });
                
                // Mouse/touch events
                this.canvas.addEventListener('mousedown', this.handleStart.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleEnd.bind(this));
                
                this.canvas.addEventListener('touchstart', this.handleStart.bind(this));
                this.canvas.addEventListener('touchmove', this.handleMove.bind(this));
                this.canvas.addEventListener('touchend', this.handleEnd.bind(this));
                
                // Restart button
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
                
                // Prevent context menu
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
            }
            
            handleStart(e) {
                e.preventDefault();
                if (!this.gameRunning) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                this.mouse.x = clientX - rect.left;
                this.mouse.y = clientY - rect.top;
                this.mouse.down = true;
                this.mouse.touches = e.touches ? e.touches.length : 1;
                
                if (this.currentTool === 'drill') {
                    this.drillCharging = true;
                    this.drillCharge = 0;
                }
                
                this.showToolbar();
            }
            
            handleMove(e) {
                e.preventDefault();
                if (!this.gameRunning) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                this.mouse.x = clientX - rect.left;
                this.mouse.y = clientY - rect.top;
                
                // Position tool cursor offset below finger with precise tip calculation
                this.mouse.toolX = this.mouse.x;
                this.mouse.toolY = this.mouse.y - 100; // Position tool above finger
                
                // Calculate precise tool tip position for hit detection
                let tipOffsetY = 0;
                switch(this.currentTool) {
                    case 'brush': tipOffsetY = 125; break;  // tip of brush bristles
                    case 'scaler': tipOffsetY = 133; break; // tip of scaler point
                    case 'drill': tipOffsetY = 130; break;  // tip of drill bit
                    case 'rinse': tipOffsetY = 110; break;  // rinse nozzle
                }
                
                this.mouse.tipX = this.mouse.x;
                this.mouse.tipY = this.mouse.y - 100 + tipOffsetY; // Actual working tip position
                
                // Update visual cursor
                this.toolCursor.style.left = (rect.left + this.mouse.x - 15) + 'px';
                this.toolCursor.style.top = (rect.top + this.mouse.toolY) + 'px';
                this.toolCursor.style.opacity = this.mouse.down ? '1' : '0';
                
                if (this.mouse.down) {
                    this.useTool();
                }
            }
            
            handleEnd(e) {
                e.preventDefault();
                this.mouse.down = false;
                this.mouse.touches = 0;
                
                // Hide tool cursor
                this.toolCursor.style.opacity = '0';
                
                if (this.currentTool === 'drill' && this.drillCharging) {
                    this.drillCharging = false;
                    if (this.drillCharge > 30) {
                        this.performDrill();
                    }
                    this.drillCharge = 0;
                }
                
                this.hideToolbarDelayed();
            }
            
            selectTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
                document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
                
                // Update cursor appearance
                this.toolCursor.className = `cursor-${tool}`;
                
                this.vibrate(30);
            }
            
            showToolbar() {
                const toolbar = document.getElementById('toolbar');
                toolbar.style.opacity = '1';
                if (this.toolbarTimeout) {
                    clearTimeout(this.toolbarTimeout);
                }
            }
            
            hideToolbarDelayed() {
                this.toolbarTimeout = setTimeout(() => {
                    const toolbar = document.getElementById('toolbar');
                    toolbar.style.opacity = '0.7';
                }, 3000);
            }
            
            generateMouth() {
                this.teeth = [];
                this.problems = [];
                
                // Generate upper teeth (8) - positioned on upper gums
                for (let i = 0; i < 8; i++) {
                    const x = 60 + i * 30 + Math.random() * 10 - 5;
                    const y = 270 + Math.random() * 15 - 7; // Fixed: positioned on upper gums
                    const width = 20 + Math.random() * 8;
                    const height = 25 + Math.random() * 10;
                    
                    this.teeth.push({
                        x, y, width, height,
                        type: 'upper',
                        crooked: Math.random() * 10 - 5,
                        stained: Math.random() < 0.3 ? 0.3 + Math.random() * 0.4 : 0
                    });
                }
                
                // Generate lower teeth (8) - positioned on lower gums  
                for (let i = 0; i < 8; i++) {
                    const x = 60 + i * 30 + Math.random() * 10 - 5;
                    const y = 340 + Math.random() * 15 - 7; // Adjusted for better positioning
                    const width = 20 + Math.random() * 8;
                    const height = 25 + Math.random() * 10;
                    
                    this.teeth.push({
                        x, y, width, height,
                        type: 'lower',
                        crooked: Math.random() * 10 - 5,
                        stained: Math.random() < 0.3 ? 0.3 + Math.random() * 0.4 : 0
                    });
                }
                
                // Generate dental problems with more variety
                const problemCount = 6 + Math.floor(Math.random() * 10);
                for (let i = 0; i < problemCount; i++) {
                    const tooth = this.teeth[Math.floor(Math.random() * this.teeth.length)];
                    const types = ['plaque', 'tartar', 'cavity'];
                    let type = types[Math.floor(Math.random() * types.length)];
                    
                    // Bias toward more plaque for better flow
                    if (Math.random() < 0.5) type = 'plaque';
                    
                    const problemX = tooth.x + Math.random() * tooth.width;
                    const problemY = tooth.y + Math.random() * tooth.height;
                    
                    this.problems.push({
                        x: problemX,
                        y: problemY,
                        type: type,
                        size: type === 'cavity' ? 3 + Math.random() * 4 : 4 + Math.random() * 6,
                        health: type === 'cavity' ? 80 + Math.random() * 40 : 30 + Math.random() * 30,
                        maxHealth: type === 'cavity' ? 100 : 50,
                        pulsePhase: Math.random() * Math.PI * 2,
                        thickness: type === 'tartar' ? 2 + Math.random() * 3 : 1
                    });
                }
            }
            
            startGame() {
                this.gameRunning = true;
                this.gameLoop();
                this.startTimer();
            }
            
            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timeLeft--;
                    document.getElementById('timerValue').textContent = this.timeLeft;
                    
                    if (this.timeLeft <= 0) {
                        this.endGame();
                    }
                }, 1000);
            }
            
            gameLoop() {
                if (!this.gameRunning) return;
                
                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // Update drill charging
                if (this.drillCharging) {
                    this.drillCharge = Math.min(100, this.drillCharge + 2);
                }
                
                // Cool down drill heat
                if (this.drillHeat > 0) {
                    this.drillHeat = Math.max(0, this.drillHeat - 0.5);
                }
                
                // Update particles with enhanced physics
                this.particles = this.particles.filter(particle => {
                    particle.life -= particle.water ? 0.025 : 0.02;
                    particle.y += particle.vy;
                    particle.vy += particle.gravity || 0.5;
                    particle.x += particle.vx;
                    
                    // Air resistance
                    particle.vx *= 0.98;
                    
                    // Rotation for chunky particles
                    if (particle.rotation !== undefined) {
                        particle.rotation += particle.rotationSpeed;
                    }
                    
                    // Bounce off mouth floor
                    if (particle.y > 400 && particle.vy > 0) {
                        particle.vy *= -0.3;
                        particle.y = 400;
                    }
                    
                    return particle.life > 0;
                });
                
                // Check win condition
                if (this.problems.length === 0 && this.gameRunning) {
                    this.perfectSmile();
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#f0f8ff';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw mouth background
                this.drawMouth();
                
                // Draw teeth
                this.drawTeeth();
                
                // Draw problems
                this.drawProblems();
                
                // Draw particles
                this.drawParticles();
                
                // Draw drill heat bar
                if (this.drillHeat > 0 || this.drillCharging) {
                    this.drawDrillHeat();
                }
            }
            
            drawMouth() {
                // Draw mouth opening
                this.ctx.fillStyle = '#2c1810';
                this.ctx.beginPath();
                this.ctx.ellipse(180, 320, 140, 80, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw gums
                this.ctx.fillStyle = '#ff9999';
                this.ctx.beginPath();
                this.ctx.ellipse(180, 280, 120, 40, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.beginPath();
                this.ctx.ellipse(180, 360, 120, 40, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawTeeth() {
                this.teeth.forEach(tooth => {
                    // Base tooth color with staining
                    const baseColor = tooth.stained > 0 
                        ? `hsl(60, ${Math.floor(60 - tooth.stained * 40)}%, ${Math.floor(95 - tooth.stained * 20)}%)`
                        : '#ffffcc';
                    
                    this.ctx.fillStyle = baseColor;
                    this.ctx.strokeStyle = '#ccccaa';
                    this.ctx.lineWidth = 1;
                    
                    this.ctx.save();
                    this.ctx.translate(tooth.x + tooth.width/2, tooth.y + tooth.height/2);
                    this.ctx.rotate(tooth.crooked * Math.PI / 180);
                    
                    // Main tooth shape
                    this.ctx.fillRect(-tooth.width/2, -tooth.height/2, tooth.width, tooth.height);
                    this.ctx.strokeRect(-tooth.width/2, -tooth.height/2, tooth.width, tooth.height);
                    
                    // Tooth shine effect
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    this.ctx.fillRect(-tooth.width/2 + 2, -tooth.height/2 + 2, tooth.width * 0.3, tooth.height * 0.6);
                    
                    this.ctx.restore();
                });
            }
            
            drawProblems() {
                const time = Date.now() * 0.005;
                
                this.problems.forEach(problem => {
                    this.ctx.save();
                    this.ctx.translate(problem.x, problem.y);
                    
                    let baseColor, pulseIntensity = 1;
                    
                    switch(problem.type) {
                        case 'plaque':
                            baseColor = '#e6e600'; // More vivid yellow
                            pulseIntensity = 0.8 + 0.2 * Math.sin(time + problem.pulsePhase);
                            break;
                        case 'tartar':
                            baseColor = '#5d2e0a'; // Darker, more gross brown
                            // Tartar has rough, chunky appearance
                            this.ctx.fillStyle = baseColor;
                            for (let i = 0; i < problem.thickness; i++) {
                                const offset = (i - problem.thickness/2) * 1.5;
                                this.ctx.beginPath();
                                this.ctx.arc(offset, offset * 0.5, problem.size * (0.7 + i * 0.1), 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                            this.ctx.restore();
                            return;
                        case 'cavity':
                            baseColor = '#0d0d0d'; // Deep black
                            pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2 + problem.pulsePhase);
                            break;
                    }
                    
                    const size = problem.size * pulseIntensity;
                    this.ctx.fillStyle = baseColor;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Health indicator for cavities
                    if (problem.type === 'cavity' && problem.health < problem.maxHealth) {
                        const healthRatio = problem.health / problem.maxHealth;
                        this.ctx.fillStyle = `rgba(255, 50, 50, ${(1 - healthRatio) * 0.8})`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Nasty glow effect for all problems
                    if (problem.type === 'plaque') {
                        this.ctx.shadowColor = '#e6e600';
                        this.ctx.shadowBlur = 5;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    
                    this.ctx.restore();
                });
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.translate(particle.x, particle.y);
                    
                    if (particle.rotation !== undefined) {
                        this.ctx.rotate(particle.rotation * Math.PI / 180);
                    }
                    
                    this.ctx.fillStyle = `rgba(${particle.color}, ${particle.life})`;
                    
                    if (particle.water) {
                        // Water droplets are more oval
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, particle.size, particle.size * 1.5, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else {
                        // Regular particles
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
            
            drawDrillHeat() {
                const barWidth = 100;
                const barHeight = 10;
                const x = 130;
                const y = 100;
                
                // Background
                this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                this.ctx.fillRect(x, y, barWidth, barHeight);
                
                // Heat level
                const heatRatio = this.drillCharging ? this.drillCharge / 100 : this.drillHeat / 100;
                this.ctx.fillStyle = this.drillHeat > 80 ? '#ff4757' : '#ffa502';
                this.ctx.fillRect(x, y, barWidth * heatRatio, barHeight);
                
                // Border
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x, y, barWidth, barHeight);
            }
            
            useTool() {
                if (!this.gameRunning) return;
                
                switch(this.currentTool) {
                    case 'brush':
                        this.useBrush();
                        break;
                    case 'scaler':
                        this.useScaler();
                        break;
                    case 'rinse':
                        if (this.mouse.touches >= 2) {
                            this.useRinse();
                        }
                        break;
                }
            }
            
            useBrush() {
                const range = 20; // Precise range for brush tip
                let cleaned = false;
                
                this.problems = this.problems.filter(problem => {
                    if (problem.type === 'plaque') {
                        const dist = Math.sqrt(
                            (problem.x - this.mouse.tipX) ** 2 + 
                            (problem.y - this.mouse.tipY) ** 2
                        );
                        
                        if (dist < range) {
                            problem.health -= 25;
                            
                            this.createParticles(
                                problem.x, problem.y, '230, 230, 0', 
                                6, { speed: 2, gravity: 0.3 }
                            );
                            
                            this.playSound('scrub');
                            cleaned = true;
                            
                            if (problem.health <= 0) {
                                this.score += 10;
                                this.comfort = Math.min(100, this.comfort + 1);
                                this.createSuccessEffect(problem.x, problem.y, '+10');
                                this.vibrate(25);
                                return false;
                            }
                        }
                    }
                    return true;
                });
                
                if (!cleaned && Math.random() < 0.05) {
                    this.comfort = Math.max(0, this.comfort - 1);
                }
                
                this.updateHUD();
            }
            
            useScaler() {
                const range = 15; // Precise targeting for scaler point
                let cleaned = false;
                
                this.problems = this.problems.filter(problem => {
                    if (problem.type === 'tartar') {
                        const dist = Math.sqrt(
                            (problem.x - this.mouse.tipX) ** 2 + 
                            (problem.y - this.mouse.tipY) ** 2
                        );
                        
                        if (dist < range) {
                            this.createParticles(
                                problem.x, problem.y, '93, 69, 19', 
                                8, { speed: 3, gravity: 0.8, chunky: true }
                            );
                            this.createSuccessEffect(problem.x, problem.y, '+15');
                            this.playSound('chip');
                            this.score += 15;
                            this.comfort = Math.min(100, this.comfort + 1);
                            this.vibrate(50);
                            cleaned = true;
                            return false;
                        }
                    }
                    return true;
                });
                
                if (!cleaned && Math.random() < 0.03) {
                    this.comfort = Math.max(0, this.comfort - 2);
                }
                
                this.updateHUD();
            }
            
            performDrill() {
                const range = 12; // Very precise for drill tip
                let drilled = false;
                
                this.problems = this.problems.filter(problem => {
                    if (problem.type === 'cavity') {
                        const dist = Math.sqrt(
                            (problem.x - this.mouse.tipX) ** 2 + 
                            (problem.y - this.mouse.tipY) ** 2
                        );
                        
                        if (dist < range) {
                            const damage = this.drillCharge * 1.2;
                            problem.health -= damage;
                            this.drillHeat = Math.min(100, this.drillHeat + 25);
                            this.createParticles(problem.x, problem.y, '26, 26, 26', 6);
                            this.screenShake();
                            drilled = true;
                            
                            if (problem.health <= 0) {
                                this.score += 25;
                                this.comfort = Math.min(100, this.comfort + 2);
                                this.createSuccessEffect(problem.x, problem.y, '+25');
                                this.vibrate(60);
                                return false;
                            }
                        }
                    }
                    return true;
                });
                
                if (!drilled) {
                    this.comfort = Math.max(0, this.comfort - 3);
                }
                
                this.updateHUD();
            }
            
            useRinse() {
                const range = 35; // Good range for water spray
                
                this.drillHeat = Math.max(0, this.drillHeat - 40);
                
                const beforeCount = this.particles.length;
                this.particles = this.particles.filter(() => Math.random() < 0.3);
                const washedAway = beforeCount - this.particles.length;
                
                // Create water spray at tool tip
                for (let i = 0; i < 12; i++) {
                    this.createParticles(
                        this.mouse.tipX + (Math.random() - 0.5) * 25,
                        this.mouse.tipY + (Math.random() - 0.5) * 25,
                        '100, 180, 255',
                        1,
                        { speed: 4, gravity: 0.2, water: true }
                    );
                }
                
                // Use tool tip position for rinse effects
                this.problems.forEach(problem => {
                    const dist = Math.sqrt(
                        (problem.x - this.mouse.tipX) ** 2 + 
                        (problem.y - this.mouse.tipY) ** 2
                    );
                    
                    if (dist < range && problem.type === 'plaque') {
                        problem.health -= 5;
                        if (problem.health <= 0) {
                            this.score += 5;
                            this.createSuccessEffect(problem.x, problem.y, '+5');
                        }
                    }
                });
                
                this.problems = this.problems.filter(p => p.health > 0);
                
                if (washedAway > 3) {
                    this.createSuccessEffect(this.mouse.tipX, this.mouse.tipY, `Clean!`);
                    this.score += Math.floor(washedAway / 2);
                }
                
                this.playSound('rinse');
                this.vibrate(40);
                this.updateHUD();
            }
            
            createParticles(x, y, color, count = 5, options = {}) {
                const { speed = 2, gravity = 0.5, chunky = false, water = false } = options;
                
                for (let i = 0; i < count; i++) {
                    const particle = {
                        x: x + (Math.random() - 0.5) * 10,
                        y: y + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * speed * 2,
                        vy: Math.random() * -speed - 1,
                        size: chunky ? Math.random() * 4 + 2 : Math.random() * 3 + 1,
                        life: water ? 0.6 : 1,
                        color: color,
                        gravity: gravity,
                        rotation: chunky ? Math.random() * 360 : 0,
                        rotationSpeed: chunky ? (Math.random() - 0.5) * 10 : 0,
                        water: water
                    };
                    this.particles.push(particle);
                }
            }

            createSuccessEffect(x, y, text) {
                const effect = document.createElement('div');
                effect.className = 'particle';
                effect.textContent = text;
                effect.style.left = x + 'px';
                effect.style.top = y + 'px';
                effect.style.color = '#4CAF50';
                effect.style.fontSize = '14px';
                effect.style.fontWeight = 'bold';
                document.getElementById('ui').appendChild(effect);
                
                setTimeout(() => effect.remove(), 1000);
            }

            createWarningEffect(x, y, text) {
                const effect = document.createElement('div');
                effect.className = 'particle';
                effect.textContent = text;
                effect.style.left = x + 'px';
                effect.style.top = y + 'px';
                effect.style.color = '#ff6b6b';
                effect.style.fontSize = '12px';
                effect.style.fontWeight = 'bold';
                document.getElementById('ui').appendChild(effect);
                
                setTimeout(() => effect.remove(), 1000);
            }

            playSound(type) {
                // Audio context simulation with visual feedback
                const colors = {
                    'scrub': '#FFE135',
                    'chip': '#8B4513', 
                    'drill': '#FF4757',
                    'rinse': '#3DAFFF'
                };
                
                if (colors[type]) {
                    const flash = document.createElement('div');
                    flash.style.position = 'absolute';
                    flash.style.top = '0';
                    flash.style.left = '0';
                    flash.style.width = '100%';
                    flash.style.height = '100%';
                    flash.style.background = colors[type];
                    flash.style.opacity = '0.1';
                    flash.style.pointerEvents = 'none';
                    flash.style.transition = 'opacity 0.1s ease';
                    document.getElementById('gameContainer').appendChild(flash);
                    
                    setTimeout(() => {
                        flash.style.opacity = '0';
                        setTimeout(() => flash.remove(), 100);
                    }, 50);
                }
            }
            
            screenShake() {
                const container = document.getElementById('gameContainer');
                container.style.transform = 'translate(2px, 2px)';
                setTimeout(() => {
                    container.style.transform = 'translate(-2px, -2px)';
                    setTimeout(() => {
                        container.style.transform = 'translate(0, 0)';
                    }, 50);
                }, 50);
            }
            
            vibrate(duration) {
                if (navigator.vibrate) {
                    navigator.vibrate(duration);
                }
            }
            
            updateHUD() {
                document.getElementById('score').textContent = `Score: ${this.score}`;
                document.getElementById('comfortValue').textContent = this.comfort;
                
                const comfortEl = document.getElementById('comfort');
                comfortEl.style.setProperty('--comfort-width', `${this.comfort}%`);
                
                if (this.comfort <= 0) {
                    this.endGame();
                }
            }
            
            perfectSmile() {
                this.gameRunning = false;
                
                const bonus = Math.floor(this.timeLeft * 5) + Math.floor(this.comfort * 2);
                this.score += bonus;
                
                const perfectEl = document.createElement('div');
                perfectEl.className = 'perfect-smile';
                perfectEl.innerHTML = `‚ú® PERFECT SMILE! ‚ú®<br>Bonus: +${bonus}`;
                document.getElementById('ui').appendChild(perfectEl);
                
                setTimeout(() => {
                    perfectEl.remove();
                    this.nextPatient();
                }, 2000);
                
                this.vibrate([100, 50, 100, 50, 100]);
            }
            
            nextPatient() {
                this.generateMouth();
                this.timeLeft = 60;
                this.comfort = 100;
                this.drillHeat = 0;
                this.particles = [];
                this.updateHUD();
                this.startGame();
            }
            
            endGame() {
                this.gameRunning = false;
                clearInterval(this.timerInterval);
                
                document.getElementById('gameOverTitle').textContent = 
                    this.comfort <= 0 ? 'Patient Discomfort!' : "Time's Up!";
                document.getElementById('finalScore').textContent = `Final Score: ${this.score}`;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restartGame() {
                document.getElementById('gameOver').style.display = 'none';
                this.score = 0;
                this.comfort = 100;
                this.timeLeft = 60;
                this.drillHeat = 0;
                this.particles = [];
                this.generateMouth();
                this.updateHUD();
                this.startGame();
            }
        }
        
        // Start the game
        new SmileCraft();
    </script>
</body>
</html>
